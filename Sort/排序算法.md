# 十大排序算法

<img src="J:\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\Sort\pxsf.png">

<img src="J:\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\Sort\时间复杂度.png">


**时间复杂度记忆**
- 冒泡 选择 插入排序需要两个`for`循环，每次只关注一个元素，平均时间复杂度为$o(n^2)$。
- 快速、归并、希尔、堆基于二分思想，以$log2$为底，平均时间复杂度为$nlog(n)$, 一遍找元素$o(n)$,一遍找位置$ log(n) $。

**稳定性记忆-“快希选堆”（快牺牲稳定性）**
- 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。

## 冒泡排序（交换）
```c++
#include<iostream>
using namespace std;

void bubble_sort(vector<int>& arr){
    int len = arr.size();
    // 第一次遍历到最后一个元素，选出最小的，往后遍历少一个元素
    for(int i = len-1; i >=0; i--){
        int flag = 0;
        for(int j = 0; j<i; j++){
            if(arr[j]<arr[j+1]){
                swap(arr[j],arr[j+1]);
                flag = 1;
            }
        }
        if(!flag) break;
    }
}

int main()
{
    vector<int> a = {6, 4, 3, 8, 1, 5, 9, 23};
    bubble_sort(a);
    for (int i = 0; i < 8; i++)
    {
        cout << a[i] << endl;
    }
}
```
- 比较相邻的元素，若前一个比后一个小，则交换他们;
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最小的数;
- 减少比较的次数，重复上述步骤;
- 重复步骤1~3，直到排序完成。


## 插入排序（插入）

**针对于一个有序序列，向其中插入元素之后，使该序列仍然有序。**

- 插入排序：每趟将一个待排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上，直到所有待排序的关键字都被插入到有序序列中为止。

- 理论上，在直接插入排序中第二层循环是可以提前结束的，即某个元素在寻找自己合适位置时并未循环遍历到序列最前端。这是直接插入排序和选择排序最大的不同。也是插入排序和选择排序同为时间复杂度O(n2)，但是插入排序效率更高的原因。尤其是在待排序数据基本有序的时候，这种优势将极其明显。甚至此时插入排序要比时间复杂度为O(nlogn)的排序算法更加高效。
  
```C++
#include<iostream>
#include<vector>
using namespace std;

void Insert_Sort(vector<int>& A){
    int N = A.size();
    for(int i=1;i<N;i++){  
// 第一个已经成序,第二个开始，当前要排元素小于前一个，前一个元素往前移动，给他腾位置
        long tmp = A[i];
        int j=i;
        for(;tmp>A[j-1] && j>0;j--)
            A[j] = A[j-1];//小元素后移
        A[j] = tmp;//合适的位置
	}
}


int main()
{
    vector<int> A= {6, 4, 3, 8, 1, 5, 9, 23};
    Insert_Sort(A);
    for (int i = 0; i <8; i++)
    {
        cout << A[i] << endl;
    }
}
```


## 选择排序（选择）

**选择排序(Selection-sort)**：是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 
```c++
void Selection_sort(vector<int>& arr){
    int N = arr.size();
    for(int i=0;i<N-1;++i){
        int maxIndex = i;//从大到小排序，
        //每一轮找最大元素
        for(int j=i+1;j<N;++j){
            if(arr[j]>arr[maxIndex])
                swap(arr[j],arr[maxIndex]);
        }
    }

}
```
- 算法分析：表现最稳定的排序算法之一，因为**无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好**。唯一的好处可能就是**不占用额外的内存空间**了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

## 快速排序（交换）

**快速排序的基本思想**：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的**关键字**均比另一部分的关键字小，则可分别对比基数大和基数小的这**两部分记录继续进行排序**，以达到整个序列有序。

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
```C++
// 大到小
void quick_sort1(vector<int>& a,int L, int R){
    if(L<R){
        int privot = a[L];
        int i = L+1;
        int j = R;
        while(i<=j){
            while(i<=j && a[j] < privot) {--j;}
            while(i<=j && a[i] >= privot) {++i;}
            if(i<=j)
                swap(a[i],a[j]);
            else 
                break;
        }
        swap(a[j],a[L]);
        quick_sort1(a,L,j-1);
        quick_sort1(a,j+1,R);
    }
}

// 小到大
void quick_sort2(vector<int>& a,int L, int R){
    if(L<R){
        int privot = a[L];
        int i = L+1;
        int j = R;
        while(i<=j){
            while(i<=j && a[j] > privot) {--j;}
            while(i<=j && a[i] <= privot) {++i;}
            if(i<=j)
                swap(a[i],a[j]);
            else 
                break;
        }
        swap(a[j],a[L]);
        quick_sort2(a,L,j-1);
        quick_sort2(a,j+1,R);
    }
}
```

## 希尔排序（插入）

**希尔排序**：是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2)的第一批算法之一。 

- 基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，**比如[5,4,3,2,1,0]这种倒序序列**，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中**采用跳跃式分组的策略**，通过某个**增量将数组元素划分为若干组**，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看**基本有序，小的基本在前，大的基本在后**。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

```c++
void shell_sort(vector<int> &a)
{
    int N = a.size();
    for (int D = N / 2; D > 0; D /= 2)// 增量序列
    {
        for (int i = D; i < N; i++)
        { //从每个增量序列的第二个开始进行插入排序
            int temp = a[i];
            int j = i;
            for (; a[j - D] > temp && j > 0; j -= D)
            { //从小到大
                a[j] = a[j - D];
            }
            a[j] = temp;
        }
    }
}
```

## 堆排序（选择）

**堆的定义**：堆是一个完全二叉树，堆中的任意一个节点值大于等于（小于等于）子树的任意节点。

（1）堆排序思想
基本思路
 * 步骤一：建立大根堆--将n个元素组成的无序序列构建一个大根堆，
 * 步骤二：交换堆元素--交换堆尾元素和堆首元素，使堆尾元素为最大元素；
 * 步骤三：重建大根堆--将前n-1个元素组成的无序序列调整为大根堆

重复执行步骤二和步骤三，直到整个序列有序。（构建大顶堆时需要堆每个非叶子节点进行比较，每次比较从右下端的第一个非叶子节点开始）

```C++
// i是需要改变的节点，
void precDown(vector<int> &A, int i, int N)
{
    // 下沉调整节点位置
    int parent, child;
    int temp = A[i];
    for (parent = i; parent * 2 + 1 < N; parent = child)
    {
        child = parent * 2 + 1;
        // 找出左右节点的较大值
        if (child != N - 1 && A[child] < A[child + 1])
            ++child;
        if (temp >= A[child])
            break; //左右孩子都小于父亲，直接退出
        else
            A[parent] = A[child]; //否则赋值给父亲较大的值
    }
    A[parent] = temp; // temp应该在的位置
}

void Heap_Sort(vector<int> &A, int N)
{
    for (int i = N / 2 - 1; i >= 0; --i)
    {
        precDown(A, i, N);
    }
    for (int i = N - 1; i > 0; --i)
    {
        swap(A[0], A[i]);
        precDown(A, 0, i);
    }
}
```

## 归并排序

**归并排序思想**：分治就是分而治之，讲一个大的问题，分成小问题进行解决。那么对于排序我们可以这样想，是不是可以将一个大的序列，分成两个长度尽量相等的序列（如果一开始是偶数，则两边元素相等，否则其中一边多一个就行），然后我们对于每一边进行排序，最后在合并就可以达成一个有序的序列。
```c++
void Merge(vector<int>& A,vector<int>& temp,int L, int R, int Rend){
    int Tmp = L;
    int Lend = R-1;
    int numsize = Rend-L+1;
    while(L<=Lend&&R<=Rend){
        if(A[L]<A[R])
            temp[Tmp++] = A[L++];
        else
            temp[Tmp++] = A[R++];
    }
    while(L<=Lend){
        temp[Tmp++] = A[L++];
    }
    while(R<=Rend){
        temp[Tmp++] = A[R++];
    }
    for (int i = 0; i < numsize; i++, Rend--)
    {
        A[Rend] = temp[Rend];
    }
}

void Msort(vector<int>& A,vector<int>& temp,int Left, int Right){
    int center;
    if(Left < Right){
        center = Left + (Right - Left)/2;
        Msort(A, temp,Left,center);
        Msort(A, temp,center+1,Right);
        Merge(A,temp,Left,center+1,Right);
    }
}

void Merge_Sort(vector<int>& A){
    int N = A.size();
    vector<int> temp (N,0);
    Msort(A, temp, 0, N-1);
}

```