&ensp;&ensp;二叉树算法的总设计路线是明确一个节点要做的事情，剩下的交给递归。


# 二叉搜索树

## 定义
&ensp;&ensp;一个二叉树中，任意节点的值要大于对于左子树所有节点的值且要小于等于右子树所有节点的值。

从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。

下面实现以下操作：判断BST的合法性，增、删。

## 判断BST的合法性
&ensp;&ensp;LeetCode_98 判断一棵树是否为二叉搜索树

```c++
bool isValidBST(TreeNode* root){
    return dg(root,nullptr,nullptr);// 判断
}

// 递归函数
bool dg(TreeNode* root,TreeNode* min,TreeNode* max){
    if(!root)
        return true;
    // 每个节点要做的就是比较自身的值与此节点最大最小值的范围，如果超出界限就是false
    if(min!=nullptr&&root->val<=min.val)
        return false;
    if(max!=nullptr&&root->val>=max.val)
        return false;
    // 递归比较左右子树
    // 传入左子树的，根节点作为max，传入右子树，根节点作为min
    return dg(root->left,min,root)&&dg(root->right,root,max);
}
```

## 在BST中搜索一个数
```c++
bool isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;
    // 当前节点没找到就递归地去左右子树寻找
    return isInBST(root.left, target)
        || isInBST(root.right, target);
}
```
上述方法适用于所有树，但是可以根据二叉搜索树的性质进行简化
```c++
bool isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target)
        return true;
    if (root.val < target) // root值小于target，取右子树找
        return isInBST(root.right, target);
    if (root.val > target) // root值大于target，去左子树找
        return isInBST(root.left, target);
    // root 该做的事做完了，顺带把框架也完成了，妙
}
```

## 在BST中删除一个数
&ensp;&ensp;首先是大体框架
```c++
TreeNode deleteNode(TreeNode root, int key) {
    if (root.val == key) {
        delete;
    } else if (root.val > key) {
        find in leftchild;
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        find in rightchild;
        root.right = deleteNode(root.right, key);
    }
    return root;
}
```
&ensp;&ensp;下面分情况进行讨论：

1. 要删除的是叶节点，那么直接删除就行，即把此节点用NULL代替。
2. 要删除的节点仅有一边子树，返回子树节点。
3. 要删除的节点两边都存在子树，用左子树最大的节点或者右子树最小来代替该节点，并删除此节点。

```c++
 int findRightMin(TreeNode* root){
        root = root->right;
        while(root->left)
            root =root->left;
        return root->val;
    }
    int findLeftMax(TreeNode* root){
        root = root->left;
        while(root->right)
            root =root->right;
        return root->val;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root)
            return nullptr;
        if(key>root->val){ //要删除的在右边
            root->right = deleteNode(root->right,key);
        }
        else if(key<root->val){//要删除的在左边
            root->left = deleteNode(root->left,key);
        }
        else{
            // 找到要删除的节点
            if(!root->left&&!root->right)
                root = nullptr;
            else if(!root->right){
                root = root->left;
            }
            else if(!root->left){
                root = root->right;
            }
            else{
                root->val = findRightMin(root);
                root->right = deleteNode(root->right,root->val);
            }
        }
        return root;
    }   
```


## BST中插入一个数
&ensp;&ensp;一旦涉及改动，则需要返回节点
```c++
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    // 若要插入的数已经存在，则直接返回
    if (root.val == val)
        return root;
    if (root.val < val) //右子树插入
        root.right = insertIntoBST(root.right, val);
    if (root.val > val) // 左子树插入
        root.left = insertIntoBST(root.left, val);
    return root;// 返回节点，递归到最底层再返回最上层，最后返回根节点
}
```


## 算法题
230.BST第K小的元素（中等）

538.二叉搜索树转化累加树（中等）

1038.BST转累加树（中等）

450.删除二叉搜索树中的节点（中等）

701.二叉搜索树中的插入操作（中等）

700.二叉搜索树中的搜索（简单）

98.验证二叉搜索树（中等）

96.不同的二叉搜索树（Easy）

95.不同的二叉搜索树II（Medium）
