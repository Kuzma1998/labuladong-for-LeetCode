<!--
 * @Description: 
 * @code: 
 * @Author: Li Jiaxin
 * @Date: 2021-12-25 09:43:44
-->

# 回溯

## 回溯的模板
```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**回溯算法能解决如下问题：**
- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等

## 组合问题

**Leetcode 77 组合**
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\1.png" width="100%">

**for**循环横向遍历当前层做选择，纵向遍历是**递归**，递归深度由k决定。

- 可以进行剪枝
**剪枝精髓**：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了。

**Leetcode 39 组合总和**
- 本题的剪枝套路就是先排序，若某一层某个数和大于目标，直接break，如下图
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\2.png" width="100%">
- 还有个trick就是对for循环的范围进行剪枝

**Leetcode 34 组合总和II**
- 本题套路与上题一样，但是可以重复使用多次数据，因此不需要传入**index**
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\3.png" width="100%">

**Leetcode 216 组合总和III**
本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。
- k相当于固定了树的深度，
- 需要传入index因为元素不能重复使用，可以对for循环的范围进行剪枝 **某一层index最多为9-(k-path.size())+1**

<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\4.png" width="100%">

**Leetcode 17电话号码的字母组合**
- 哈希表存入字母数字的映射
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\5.png" width="100%">

## 切割问题

**Leetcode 131分割回文串**
- 切割问题其实类似组合问题
- 如何模拟那些切割线
- 切割问题中递归如何终止
- 在递归循环中如何截取子串
- 如何判断回文

<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\6.png" width="100%">

**Leetcode 93复原IP地址**

与上题一样的套路
- 如何判断是合法的字符串？
- 如何模拟切割即插入'.'？
- 记得传入index+2

## 子集问题

**Leetcode 78子集**
给你一个整数数组nums ，数组中的元素互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1：
输入：nums = [1,2,3]
输出：[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]

<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\7.png" width="100%">

**Leetcode 90子集II**
给你一个整数数组nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集不能包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
输入：nums = [1,2,2]
输出：[],[1],[1,2],[1,2,2],[2],[2,2]

- 因为数组包含重复元素，因此树的层进行去重操作
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\8.png" width="100%">

**Leetcode 491递增子序列**

- 一般情况可以通过排序，用used数组进行去重，但是本题利用集合进行去重！！！
- 注意和子集问题的90题的区别
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\9.png" width="100%">


## 排列问题
**特点**
- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了


**Leetcode 46全排列**

<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\10.png" width="100%">



**Leetcode 47全排列II**
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
输入：nums = [1,1,2]
输出：
[1,1,2],
[1,2,1],
[2,1,1]
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\11.png" width="100%">

- 先排序，利用used数组进行去重

##  去重
<img src="F:\OneDrive2\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\回溯\Pictures\12.png" width="100%">


## 棋盘问题
**数独**
**N皇后**