# 十大排序算法

<img src="J:\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\十大排序算法\pxsf.png">

<img src="J:\OneDrive - csu.edu.cn\C++learning\Data_Structure_LC\十大排序算法\时间复杂度.png">


**时间复杂度记忆**
- 冒泡 选择 插入排序需要两个`for`循环，每次只关注一个元素，平均时间复杂度为$o(n^2)$。
- 快速、归并、希尔、堆基于二分思想，以$log2$为底，平均时间复杂度为$nlog(n)$, 一遍找元素$o(n)$,一遍找位置$ log(n) $。

**稳定性记忆-“快希选堆”（快牺牲稳定性）**
- 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。

**冒泡排序**
```c++
#include<iostream>
using namespace std;

void bubble_sort(vector<int>& arr){
    int len = arr.size();
    // 第一次遍历到最后一个元素，选出最小的，往后遍历少一个元素
    for(int i = len-1; i >=0; i--){
        int flag = 0;
        for(int j = 0; j<i; j++){
            if(arr[j]<arr[j+1]){
                swap(arr[j],arr[j+1]);
                flag = 1;
            }
        }
        if(!flag) break;
    }
}

int main()
{
    vector<int> a = {6, 4, 3, 8, 1, 5, 9, 23};
    bubble_sort(a);
    for (int i = 0; i < 8; i++)
    {
        cout << a[i] << endl;
    }
}
```
- 比较相邻的元素，若前一个比后一个小，则交换他们;
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最小的数;
- 减少比较的次数，重复上述步骤;
- 重复步骤1~3，直到排序完成。


## 插入排序

**针对于一个有序序列，向其中插入元素之后，使该序列仍然有序。**

- 插入排序：每趟将一个待排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上，直到所有待排序的关键字都被插入到有序序列中为止。

- 理论上，在直接插入排序中第二层循环是可以提前结束的，即某个元素在寻找自己合适位置时并未循环遍历到序列最前端。这是直接插入排序和选择排序最大的不同。也是插入排序和选择排序同为时间复杂度O(n2)，但是插入排序效率更高的原因。尤其是在待排序数据基本有序的时候，这种优势将极其明显。甚至此时插入排序要比时间复杂度为O(nlogn)的排序算法更加高效。
  
```C++
#include<iostream>
#include<vector>
using namespace std;

void Insert_Sort(vector<int>& A){
    int N = A.size();
    for(int i=1;i<N;i++){  
// 第一个已经成序,第二个开始，当前要排元素小于前一个，前一个元素往前移动，给他腾位置
        long tmp = A[i];
        int j=i;
        for(;tmp>A[j-1] && j>0;j--)
            A[j] = A[j-1];//小元素后移
        A[j] = tmp;//合适的位置
	}
}


int main()
{
    vector<int> A= {6, 4, 3, 8, 1, 5, 9, 23};
    Insert_Sort(A);
    for (int i = 0; i <8; i++)
    {
        cout << A[i] << endl;
    }
}
```


## 选择排序

## 快速排序

**快速排序的基本思想**：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的**关键字**均比另一部分的关键字小，则可分别对比基数大和基数小的这**两部分记录继续进行排序**，以达到整个序列有序。

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。